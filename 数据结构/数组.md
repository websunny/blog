# 数组

## 创建数组

1.字面量声明 通过[]操作符

`var array = []`

2.构造函数声明

`var array = new Array()`

>大多数 JavaScript 专家推荐使用 [] 操作符，和使用 Array 的构造函数相比，这种方式被认为效率更高(具体参见 O’Reilly 出 版的 JavaScript: The Definitive Guide 和 JavaScript: The Good Parts 这两本书)。

在实际编码中，我们也往往采用了字面量的声明方式，在方便的同时，也避免了Array全局变量被修改带来的影响。

3.由字符串生成数组

通过字符串的split()方法，可以将字符串转化为数组。

`var array = string.split("...")`

## 数组复制

我们可以通过赋值运算符 = 完成数组都赋值

```js
var nums = [];
for (var i = 0; i < 10; ++i) {
    nums[i] = i+1;
}
var samenums = nums;
```
在JavaScript中，数组和对象一样都属于引用类型，也就意味着它们被存放在堆内存中，实际上保存着的是一个指针，用于找到在堆内存中的内容，在赋值过程中，仅仅完成了指针的复制，因此当我们修改一个数组内容时，赋值堆数组也会有相应的修改

在实际编码中，我们并不需要这种‘浅复制‘，而是希望获得这个数组的克隆体，因此我们需要为这个克隆体申请一个新的内存地址。

```js
for (var i = 0; i < arr1.length; ++i) {
    arr2[i] = arr1[i];
}    
// 或者你可以选择es6的三点拓展运算符完成
arr2 = [...arr1]
```
上面完成了数组的克隆，当然这是建立在数组中每个元素都是基本类型的情况下，对于元素为引用类型，使用递归的思想可以解决，这里就不多赘述


## 存取函数
>JavaScript 提供了一组用来访问数组元素的函数，叫做存取函数，这些函数返回目标数组的某种变体。

indexOf() 函数是最常用的存取函数之一，用来查找传进来的参数在目标数组中是否存在。 如果目标数组包含该参数，就返回该元素在数组中的索引;如果不包含，就返回 -1。如果存在多个符合条件的，则返回第一个索引，lastIndexOf则返回最后一个的索引

`arr.indexof('hello world')`

jion()和上述的split方法相反，用于将数组转化为字符串形式,返回以参数连接数组中的元素的字符串。不传参数则默认传 ',' 

`arr.jion('_')`

slice()方法 可从已有的数组中返回选定的元素。该方法的第一个参数是起始索引，第二个参数是结束索引，不传则默认传数组的长度。如果参数传负数则表示，数组倒数第n位为起始索引。
满足的是前闭后开的规则[....)，也就是结束索引为元素不返回.

`arr.slice(-2,-1)` 返回的是数组的倒数第二位

concat()方法 返回合并后的数组，接受所有类型的参数

`arr.concat(arr1,'a',1,null,{a:1})`
## 可变函数
>JavaScript 拥有一组可变函数，使用它们，可以不必引用数组中的某个元素，就能改变数组内容。这些函数常常化繁为简，让困难的事情变得容易。

push和unshift可以使我们往数组中添加元素，区别在于前者将元素添加在数组末尾，后者添加在数组头部.返回新数组长度

`arr.push(1,2,3)  arr.unshift(1,2,3)`

pop和shift可以使我们往数组中删除元素，区别在于前者将删除数组最后一位元素，后者删除数组第一位元素. 返回删除元素值。传参数，并没有什么用

`arr.pop()  arr.shift('hello world')`

splice可以使我们在数组的中间进行添加或者删除操作，第一个参数表示，其实位置索引，如果参数传负数则表示，数组倒数第n位为起始索引。第二个表示长度，后续的参数为前面截取内容后补充的内容。

`arr.splice(-2,1,'hello world')` 

将倒数第二位元素替换为“hello world”

reverse将数组进行倒转

`arr.reverse()`

sort方法可以使我们根据一定规则对数组进行排序

`arr.sort()`

当不传参数时，则默认按照首个字符的ASCll码值的大小进行排序，当其中元素存在对象时，我发现首字母并不是按照' { '计算的而是 '['。

接受一个函数作为参数,函数内返回为为正则两者需要调换顺序，下面就是我们最常见的大小比较函数

```js
function compare(num1, num2) {
    return num1 - num2;
}
```

## 迭代器方法

>最后一组方法是迭代器方法。这些方法对数组中的每个元素应用一个函数，可以返回一个 值、一组值或者一个新数组。

### 不生成新数组的迭代器方法

forEach方法接受一个函数作为参数，对数组中的每个元素 使用该函数

```js
let arr = [1,2,3,4]
let newArr = []
arr.forEach( value => {newArr.push(value + 1)})
// newArr => [2,3,4,5]
```

every方法接受一个返回值为布尔类型的函数，对数组中的每 个元素使用该函数。如果对于所有的元素，该函数均返回 true，则该方法返回 true。
```js
let arr = [1,2,3,4]
arr.every( value => {return value > 0})
// true
```
some方法也接受一个返回值为布尔类型的函数，只要有一个元素使得该函数返回 true，该方法就返回 true。
```js
let arr = [0,1,2,3,4]
arr.some( value => {return value > 0})
// true
```
reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。

```js
arr.reduce(callback,initialValue)
```
callback （执行数组中每个值的函数，包含四个参数）

    1、previousValue （上一次调用回调返回的值，或者是提供的initialValue）
    2、currentValue （数组中当前被处理的元素）
    3、index （当前元素在数组中的索引）
    4、array （调用 reduce 的数组）

如果不传initialValue，则callback的第一个参数为数组的第一位

```js
var  arr = [1, 2, 3, 4];
var  add = function(prev, cur, index, arr) {
    console.log(prev, cur, index);
    return prev + cur;
}

arr.reduce(add)
// 输出
1 2 1
3 3 2
6 4 3
10
arr.reduce(add,1)
//输出
1 1 0
2 2 1
4 3 2
7 4 3
11

```

如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。因此当空数组进行reduce操作时，如果你没有设置初始值会报错。reduce还有很多用法，可以解决实际工作中的很多问题，之后也会额外写一篇文章进行进一步探究。

### 生成新数组的迭代器方法
>有两个迭代器方法可以产生新数组:map() 和 filter()。map() 和 forEach() 有点儿像，对 数组中的每个元素使用某个函数。两者的区别是 map() 返回一个新的数组，该数组的元素 是对原有元素应用某个函数得到的结果。

map() 和 forEach() 有点儿像，对 数组中的每个元素使用某个函数。两者的区别是 map() 返回一个新的数组，该数组的元素 是对原有元素应用某个函数得到的结果。

在写react时经常会用到这个函数，一般我会将函数中第二个参数索引，加上单词构成key
```js
let arr = [1,2,3,4]
arr.map( value => {return value + 1})
// [2,3,4,5]
```

filter() 和 every() 类似，传入一个返回值为布尔类型的函数。和 every() 方法不同的是， 当对数组中的所有元素应用该函数，结果均为 true 时，该方法并不返回 true，而是返回 一个新数组，该数组包含应用该函数后结果为 true 的元素。

```js
let arr = [0,1,2,3,4]
arr.filter( value => {return value > 0})
// [1,2,3,4]
```